{"tagline":"Improving the readability of test code","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Niceassert","google":"","body":"The Niceassert library defines a few useful Java tools designed to aid test readability by reducing the code overhead of various common testing patterns. It works well alongside existing widely-used testing frameworks (especially JUnit4/JMock2 with which it shares support library requirements).\r\n\r\n##Features:\r\n\r\n * Expectations - a concise way to express expected behaviour of a method call    \r\n * Overriding - partially mock the behaviour of an object\r\n * Matchers - a collection of various useful Hamcrest Matchers\r\n\r\n\r\n###Problem\r\nJUnit 4 introduced the concept of being able to add an assert that a given exception has been thrown during the course of a test, as a replacement for the repetition of the standard try-test-fail-catch-pass loop seen below:\r\n\r\n```java\r\n// JUnit 3\r\npublic void testExceptionalThing() { \r\n    try {\r\n        new ObjectUnderTest().doSomethingThatCausesAnException();\r\n        fail();\r\n    } catch (AnExpectedException e) {\r\n        // no assertion here guv!\r\n    }\r\n}\r\n\r\n// JUnit 4\r\n@Test (expected = AnExpectedException.class)\r\npublic void exceptionalThing() { \r\n    new ObjectUnderTest().doSomethingThatCausesAnException();\r\n}\r\n```\r\n\r\nHowever, there is a trade-off for the reduction in verbosity - you lose the ability to perform any additional assertions on the thrown exception.\r\n\r\n###Solution\r\nNiceassert uses a more natural language structure which allows you to combine the density of the JUnit4 case with the ability to assert on the result of any method call (using the awesome Hamcrest library). For consistency, you can also use it perform assertions on the result value of a call or to invoke a custom Matcher. The setup assertion is performed \"inline\" by the call at the end of the structure and a standard AssertionError raised if it is not matched:\r\n\r\n```java\r\nexpect(new AReturningObject()).to(throwException(AN_EXCEPTION)).whenCalling().aMethod(\"INVALID ARGUMENT\");\r\n// or:\r\nexpect(new AThrowingObject()).to(returnValue(RESULT)).whenCalling().aMethod(\"ARGUMENT\");\r\n// or:\r\nexpect(new AWorldUpdatingObject()).to(resultIn(new CustomMatcherToCheckStateOfTheWorld())).whenCalling().aMethod(\"ARGUMENT\");\r\n```\r\nFor example code, please see the examples in the source tree.\r\n\r\n###Problem\r\nIn order to assert or recreate a particular behaviour, it is often required (although not necessarily desirable) to override methods in a particular concrete class, which results in test code that looks similar to:\r\n\r\n```java\r\nObject objectToOverride = new Object() {\r\n    public String toString() {\r\n        return \"KNOWN RESULT\";\r\n    }\r\n};\r\n\r\nassertThat(objectToOverride.toString(),is(equalTo(\"KNOWN RESULT\")));\r\n```\r\n\r\nIn the case that more than one method is overridden the readability of the test code is badly affected. In the case that you are working with source code that pre-dates/doesn't use the \"Override\" annotation, removing the method in the overridden class may even leave the overridden method orphaned.\r\n\r\n###Solution\r\nNiceassert provides not just a mechanism to implement the same thing in a compact format, but also to be able to use Hamcrest parameter matching in which the proxy will fall through to the delegate implementation if the invocation doesn't match.\r\n\r\nThere are 2 methods available to override behaviour and obtain access to the proxy. The first uses a JMock2-style setup block:\r\n\r\n```java\r\nAnObject proxy = new Override<AnObject>(target) {{\r\n    will(returnValue(\"a different value\")).whenCalling().aMethod(\"ARGUMENT\");\r\n    will(throw(new RuntimeException())).whenCalling().aMethod(\"ARGUMENT\");\r\n}}.proxy();\r\n```\r\n\r\nThe other method is more compact, but requires an initial \"wrapping\" mechanism and only supports exact argument matching (ie. no Hamcrest matchers). Some may find it a little less readable in trade off for the compactness:\r\n\r\n```java\r\nOverrider<AnObject> overrider = Overrider.wrapForOverride(originalTarget);\r\noverrider.will(returnValue(OVERRIDDEN_VALUE)).whenCalling().aMethod(\"ARGUMENT\"));\r\noverrider.will(throw(new RuntimeException())).whenCalling().aMethod(\"INVALID ARGUMENT\");\r\nAnObject proxy = overrider.proxy();\r\n```\r\n\r\nRegardless of how the proxy is created, you can then just call it in place of the original target:\r\n\r\n```java\r\nproxy.methodToOverride(\"DIFFERENT ARGUMENT\"); // original target is called\r\nproxy.methodToOverride(\"ARGUMENT\");           // proxy is called\r\n```\r\n\r\nFor example code, please see the examples in the source tree.\r\n"}